##### 1. 專案範圍界定

###### 必做功能 (MVP)

- [ ] 檔案上傳（.txt/.html 限 1MB）

  - 描述：使用者可從本地上傳內容檔，自動填入郵件內容欄位。
  - 理由：關鍵操作體驗，提升內容取得便利性。

- [ ] 郵件內容欄位驗證

  - 描述：空內容時不可提交，顯示錯誤提示。
  - 理由：防止無效請求與誤操作。

- [ ] 冷卻時間控制（10 秒內不得重複提交）

  - 描述：按下「用魔法打敗魔法」後，進入 10 秒冷卻狀態。
  - 理由：保護系統資源，避免濫用。

- [ ] JWT 註冊與驗證流程

  - 描述：首次呼叫 /jwt 產出 token，之後呼叫 /generate 時加上 Authorization。
  - 理由：簡易驗證身分流程，利於後續限流與追蹤。

- [ ] 內容異動檢查機制

  - 描述：若內容與魔法類型皆無異動，阻擋請求並顯示提示。
  - 理由：避免重複分析、浪費成本。

- [ ] LLM 功能串接 + 單一魔法項目（如標題預覽雙劍合璧）

  - 描述：實作其中一項最具代表性魔法功能。
  - 理由：展示 LLM 整合成果，建立功能樣板。

- [ ] Rate limit 處理（/generate 超過次數回 429）
  - 描述：對 /generate API 實施速率限制，超過次數返回 429。
  - 理由：保護系統不被濫用，確保服務穩定。

###### 加分功能 (時間允許)

- [ ] 魔法功能：郵件標題優化（第一印象很重要）

  - 顯示 1~3 組標題建議，支援點選複製。
  - ⏳ 預估工時：0.5 天

- [ ] 魔法功能：預覽文字建議（吸引眼球的秘訣）

  - 顯示多組預覽建議文字。
  - ⏳ 預估工時：0.5 天

- [ ] 魔法功能：垃圾郵件風險檢測（避開垃圾桶的命運）

  - 顯示分數、風險說明與建議，格式簡潔明瞭。
  - ⏳ 預估工時：0.5 天

- [ ] 魔法功能：內容關鍵標籤（抓住重點）

  - 顯示 10 組關鍵字詞，支援複製。
  - ⏳ 預估工時：0.3 天

- [ ] 魔法功能：語氣與情感分析（懂你說話的感覺）

  - 顯示語氣類型與文字描述。
  - ⏳ 預估工時：0.5 天

- [ ] 魔法功能：行動號召強化（讓讀者乖乖點擊）
  - 提供 CTA 優化句子 1~3 組。
  - ⏳ 預估工時：0.5 天

###### 明確不做的功能

- 無

##### 2. 初步技術架構

###### 系統架構圖

![系統架構圖](./Architecture.svg)

###### 核心元件說明

例如：

- **User Interface**: 提供用戶與系統互動的入口，包含郵件內容輸入、上傳檔案等。
- **API Gateway**: 統一處理所有請求，包含 JWT 機制、Rate limit、請求驗證與 /generate 呼叫。
- **Auth Service**: 產生與驗證 JWT，保護 API 存取權。
- **LLM Service**: 整合 OpenAI 等 LLM 服務，提供內容生成與分析。
- **LLM Worker Process**: 處理從 Kafka 接收的任務，呼叫 LLM API 並處理回應。
- **Kafka Queue System**: 作為非同步任務分派通道，避免前後端阻塞。
- **PostgreSQL Database**: 儲存任務紀錄、使用者紀錄與分析結果。

###### 資料流設計說明

使用者於前端輸入/上傳郵件內容，選擇魔法類型

前端驗證欄位內容、冷卻時間與是否異動，若無誤則送出 /generate 請求

FastAPI 驗證 JWT、過濾過度頻繁請求，並將任務推入 Kafka

Worker 從 Kafka 讀取任務、呼叫 OpenAI 取得內容建議

將結果寫入 PostgreSQL、回傳給前端顯示

使用者可複製建議內容

##### 3. 技術選型考量

###### 後端框架

**選擇**: FastAPI
**理由**:

- 優點 1：支援非同步架構，效能佳 FastAPI 基於 ASGI 架構，天然支援非同步處理，適合整合 Kafka、Redis 等非同步服務，能有效處理高併發請求。
- 優點 2: FastAPI 使用 Python type hint 撰寫路由與資料模型，結合 Pydantic 驗證清晰且自動生成 OpenAPI 文件，能加快開發與前後端協作效率。
- 為什麼不選其他方案: Flask 功能輕量但需額外安裝驗證與 Swagger 套件，整合非同步服務相對困難；Django 雖功能齊全但偏向同步、開發流程偏重，對本專案較顯沉重。FastAPI 則提供更快的上手與擴展彈性，是現階段的最佳選擇。

###### 資料庫

**選擇**: PostgreSQL  
**理由**: 考慮資料特性、查詢需求、擴展性等因素，PostgreSQL 為最合適選擇

- 優點 1: 結構化資料儲存：支援欄位型設計與資料正規化，適合儲存使用者紀錄、請求紀錄、分析內容
- 優點 2: 支援 JSONB 格式，適合儲存非結構化資料
- 優點 3: 社群成熟(Star 18.2K)、擴充性強：與 Kafka、Python ORM（如 SQLAlchemy、Tortoise ORM）整合度高，部署穩定性佳。
- 優點 4: PostgreSQL 後續可水平擴展：支援複寫、分區（Partitioning）
- 為什麼不選其他方案: MongoDB（適合 schema-free 但查詢成本高），PostgreSQL 在本專案中兼顧開發彈性與穩定性。

###### AI 整合策略及成本控管機制

**選擇**: OpenAI GPT-4o-mini
**理由**: 本專案選擇整合 OpenAI GPT-4o-mini 作為 AI 處理主力，主要考量為「API 成本控制」與「功能完整度仍具備實用性」，適合初期開發與展示。為有效控制 API 成本與資源使用，本次專案設計了多層防護機制，包括：檢查內容是否有異動才送出請求、每次請求後設置 10 秒冷卻時間避免頻繁操作、每人每分鐘最多 5 次請求（超過即回傳 429），並僅回傳必要欄位（如標題、預覽等）以降低 token 消耗。這些策略能有效節省重複分析與控制開銷。

##### 4. 部署方式

**選擇**: Docker + Kubernetes  
**理由**: Docker 提供輕量級容器化部署，Kubernetes 則提供彈性擴展與管理能力。這樣的組合能確保系統在高負載下仍能穩定運行，並且易於維護與升級。具體部署流程如下：

1. 使用 Dockerfile 建立應用程式容器映像檔。
2. 將映像檔推送至 Docker Registry。
3. 在 Kubernetes 集群中建立 Deployment，指定映像檔與資源需求
4. 配置 Service 以暴露應用程式，並設定 Ingress 控制器處理外部流量。
5. 使用 ConfigMap 與 Secret 管理應用程式設定與敏感資訊。

##### 5. 專案時程粗估

- **天數**: 6 天
- **理由**:
- **Day 1~2**:
  - 建立 Git 專案與資料夾結構（backend、frontend、k8s）
  - FastAPI 實作 /jwt 發 token 機制
  - 本地 docker-compose：PostgreSQL + Kafka 測試環境
  - 撰寫 backend Dockerfile、Vue 初版頁面
- **Day 3**:
  - 前端上傳功能（副檔名 + 檔案大小限制）
  - 加入內容非空、冷卻倒數、按鈕禁用
  - 前端串接 /generate 測試、撰寫 frontend Dockerfile
- **Day 4**:
  - /generate 接收請求、驗證 JWT、推 Kafka 任務
  - Worker 處理任務 → GPT 回應 → 寫入 PostgreSQL
  - 撰寫後端 / Worker Kubernetes YAML 初稿
- **Day 5**:
  - 前端完成建議數量與複製功能
  - 後端加上 Rate Limit、錯誤提示
  - YAML 加入 ENV/資源限制，部署至 K8s 測試通過
- **Day 6**:
  - 全體測試（冷卻、內容變更、寫入流程）
  - 撰寫 README 與部署指令（Docker build、kubectl apply）
  - 優化 UX，完成額外功能（如垃圾信偵測）
